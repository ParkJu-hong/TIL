# HTTPS, CA, Token etc..

## 참..고..해쉬값이랑 특정알고리즘으로 암호화된 것은 다르다.. (잘못쓴 것 같아서..)

# HTTPS

http 프로토콜에 secure, 보안이 추가된 프로토콜 요청을 말한다.

https로 서버를 열기위해선 https 모듈을 npm에서 다운받아서 사용할 것, 사용법은 http모듈과 비슷하다.

https로 통신하는 것들 중에, 대칭키, 비대칭키(공개키)가 있는데.

## 대칭키

: 클라이언트와 서버가 동일한 Key(해쉬값을 복호화 할 수 있는 알고리즘)을 가지고 있어서 그 동일한 key로 통신할 데이터를

암호화해서 서로가 그 암호화된 데이터를 가지고 있는 동일한 key로 복호화하여 통신하는 방식이다. 다만 맨 처음 서버가 클라이언트에게 키를 줄때는 그 key가 그대로 노출되기때문에 위험하다.

## 비대칭키(공개키)

: 서버에서 모든 클라이언트들에게 공개된 키를 배포한다. 그리고 그 공개된키로 암호화를 해서 서버에 request하게 되면 서버는 서버 혼자 가지고 있는 개인키로 그 공개된 키로 암호화한 해쉬값을 복호화 할 수 있다.

## CA(Certificate Authority)

: https 통신시 클라이언트가 서버에게 처음으로 요청을 보내면 서버가 CA인증서와 함께 응답을 보낸다. 이과정을 핸드쉐이크라고 한다.

또한 클라이언트는 그 CA인증서가 공인된 인증기관에서 인증받은 것이 맞는지 확인하기위해 서버로부터 받은 CA인증서를 CA에 요청을 보낸다. 그 CA인증서는 CA공인기관의 개인키로 복호화할 수 있다. 만약 복호화가 가능하다면 CA인증서가 올바른 것이라고 응답을 보내고, 아닐시에는 올바른 것이 아니라고 응답을 보낸다. 또한 CA인증기관이 응답을 할때 웹서버의 공개키를 전달한다. 그 공개키로 서버와 통신을 하게 되는 것이다.

핸드쉐이크할때 맨처음 클라이언트가 생성한 무작위한 데이터와 서버로부터 받은 공개키를 혼합해서 임의의 키를 만든다.

그리고 그 임의의 키를 공개키로 암호화해서 서버에 보낸다. 그럼 이제 서버도 그 임의의키를 가지고 있으니 클라이언트와 서버는 그 임의의키를 가지고 대칭키통신을 하게 된다. 왜냐하면 비대칭키는 매번하기엔 서버든 클라이언트는 부하가 심하기 때문이다. 그래서 비대칭키통신은 대칭키통신을 위해 맨처음 하는 것이라고 생각하면 된다. 그치만 그 이후에 대칭키랑 비대칭키 통신이 같이 쓰이므로 유의하여야함

그렇다면 클라이언트는 서버에 공개키로 암호화된 데이터를 보낸다. 그리고 서버는 그 해쉬값을 개인키로 복호화한다.

# Hashing

어떤 항목의 키만을 가지고 바로 항목이 들어 있는 배열의 인덱스를 결정하는 기법

# Cookie

쿠키는 서버에서 클라이언트에 데이터를 저장하는 방법의 하나이다.

클라이언트가 서버에 요청을 보내서 특정 사용하고 싶은 서비스를 매번 Authentication할 필요없이 클라이언트에 저장하여 Authorazation할 수 있도록 한다. 

ex) 로그인창 아이디 자동완성, 로그인하지 않은 상태로 물건 장바구니 추가, 웹 공지사항 하루동안 안보기 etc ...

# Session

사용자가 인증에 성공한 상태를 세션이라고 한다. 또한 쿠키에 담기 위험한 정보들을 세션에서 서버가 관리한다.

또한 SessionId라는 값을 쿠키에 할당하여 사용자가 Authorazation할 수 있도록 한다.

(Authorazation의 토큰방식인 Token-based Authentication, JWT방식이 아닌..)

# CSRF

해커가 클라이언트가 서버에 하는 요청을 조작하여 권한을 Authoraztion할 수 있도록 하는 해킹방식 중 하나

# JWT (Json Web Token)

토큰 표딱지를 반으로 찢어서 서버가 반을 갖고 나머지 반을 클라이언트에게 준다.

그리고 클라이언트가 토큰 표딱지와 함께 서버에 요청하게 되면 서버가 서버의 메모리에 있는 나머지 반이랑 대조를 해서 맞으면 응답을 보낸다.

이때 웹서버가 여러개있을 경우가 있으니.. DB나 하드디스크가 아닌 여러개의 웹서버의 공용메모리인

레디스, Memcached와 같은 메모리형 DB에 토큰표딱지를 놓는다.

다만 JWT의 단점이.. 토큰 표딱지를 한 번 주고나면 그 토큰 표딱지로 Authorazation을 계속 하기때문에 이를 악용하는 것을 방지하고자

Access 토큰 (짧은) 길어야 몇분 가는 토큰과 Refresh 토큰 (2주?), 즉 토큰 두개를 발급해준다.

Access 토큰는 매번 인가를 받을 때 쓰는 수명 짧은 토큰

Refresh 토큰은 Access을 재발급받을 때 사용하는 토큰이다.

토큰 표딱지는 다음과 같이 생겼다

# Token

### xxxxxx.yyyyyyy.zzzzzz

x구역은 header

Header는 이것이 어떤 종류의 토큰인지(지금의 경우엔 JWT), 어떤 알고리즘으로 sign(암호화) 할지가 적혀있습니다.Header을 Base64로 디코딩(인코딩?)하면 JSON형태가 나온다.

```jsx
{
  "alg": "HS256",
  "typ": "JWT"
}
```

y구역은 payload로 서비스가 사용자에게 이 토큰을 통해 공개하기 원하는 내용을 담고있다. 이 payload를 Base64로 디코딩(인코딩?)하면 JSON형태가 나온다.

```jsx
Payload에는 정보가 담겨 있습니다. 어떤 정보에 접근 가능한지에 대한 권한을 담을 수도 있고, 
사용자의 유저 이름 등 필요한 데이터는 이곳에 담아 암호화 시킵니다. 물론 암호화(헤더에서 정의한)가 될
정보지만, 민감한 정보는 되도록 담지 않는 것이 좋습니다.
```

ex) 이 토큰을 누가 누구에게 발급했는지, 토큰이 언제까지 유효한지

```jsx
{
  "sub": "someInformation",
  "name": "phillip",
  "iat": 151623391
}
```

z구역은 signature으로써 

서버에 가지고 있는 개인키와 header, payload를 돌려서 서명의 값과 같으면 요청이 성공해서 서버가Authorazation을 하게 된다.

# Token-based Authentication

### **토큰기반 인증의 장점**

1. Statelessness & Scalability (무상태성 & 확장성)
    - 서버는 클라이언트에 대한 정보를 저장할 필요 없습니다 (토큰 해독이 되는지만 판단합니다)
    - 클라이언트는 새로운 요청을 보낼때마다 토큰을 헤더에 포함시키면 됩니다
        - 서버를 여러개 가지고 있는 서비스라면 더더욱 빛을 발휘합니다 (같은 토큰으로 여러 서버에서 인증 가능)
2. 안전하다
    - `암호화` 한 토큰을 사용하고, 암호화 키를 노출 할 필요가 없기 때문에 안전합니다
3. 어디서나 생성 가능하다
    - 토큰을 확인하는 서버가 토큰을 만들어야 하는 법이 없습니다
    - 토큰 생성용 서버를 만들거나, 다른 회사에서 토큰관련 작업을 맡기는 것 등 다양한 활용이 가능합니다
4. 권한 부여에 용이하다
    - 토큰의 payload(내용물) 안에 어떤 정보에 접근 가능한지 정할 수 있습니다
        - ex) 서비스의 사진과 연락처 사용권한만 부여

# Authentication

인증 

⇒ 맨 처음 서비스를 이용할 수 있도록 권한을 인증받는 것

# Authorazation

인가

⇒ 별도에 반복되는 로그인없이 서비스를 이용할 수 있도록 권한을 인가받는 것

### 

## Salt

소금..이다.. 해쉬값이나 특정 알고리즘으로 암호화된 값에 소금으로 간을 하듯 salt 값을 넣어서 보안을 더 강화한다.
